SET check_function_bodies = false;
CREATE FUNCTION public.set_current_timestamp_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  _new record;
BEGIN
  _new := NEW;
  _new."updated_at" = NOW();
  RETURN _new;
END;
$$;
CREATE TABLE public.smart_plug_metrics (
    "time" timestamp with time zone NOT NULL,
    power numeric NOT NULL,
    smart_plug_chip_id text NOT NULL
);
CREATE TABLE public.command (
    id integer NOT NULL,
    type text NOT NULL,
    lab_id integer NOT NULL,
    is_recurring boolean NOT NULL,
    recurrence_pattern text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    scheduled_time timestamp with time zone,
    name text NOT NULL,
    CONSTRAINT recurrence_pattern_or_scheduled_time_violation CHECK (((is_recurring AND (recurrence_pattern IS NOT NULL) AND (scheduled_time IS NULL)) OR ((NOT is_recurring) AND (recurrence_pattern IS NULL) AND (scheduled_time IS NOT NULL))))
);
CREATE SEQUENCE public.command_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE public.command_id_seq OWNED BY public.command.id;
CREATE TABLE public.command_selector (
    id integer NOT NULL,
    command_id integer NOT NULL,
    selector text NOT NULL,
    CONSTRAINT valid_selector CHECK ((selector ~ '^[0-9]+(\.[A-Za-z0-9_]+)*$'::text))
);
CREATE SEQUENCE public.command_selector_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE public.command_selector_id_seq OWNED BY public.command_selector.id;
CREATE TABLE public.command_type (
    type text NOT NULL,
    comment text
);
CREATE TABLE public.lab (
    id integer NOT NULL,
    name text NOT NULL,
    description text,
    location text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);
CREATE TABLE public.lab_station (
    id integer NOT NULL,
    name text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    lab_id integer NOT NULL
);
CREATE TABLE public.lab_user_role (
    id integer NOT NULL,
    lab_id integer NOT NULL,
    user_id text NOT NULL,
    role_id integer NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);
CREATE SEQUENCE public.lab_user_role_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE public.lab_user_role_id_seq OWNED BY public.lab_user_role.id;
CREATE TABLE public."user" (
    id text NOT NULL,
    name text NOT NULL,
    email text NOT NULL
);
COMMENT ON TABLE public."user" IS 'The only entity allowed to create users in this table is our backend, which gets activated by Firebase, otherwise we risk running into syncing issues between the auth provider and our own user table.';
COMMENT ON COLUMN public."user".id IS 'This id is generated by firebase.';
CREATE SEQUENCE public.lab_users_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE public.lab_users_id_seq OWNED BY public."user".id;
CREATE SEQUENCE public.laboratory_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE public.laboratory_id_seq OWNED BY public.lab.id;
CREATE TABLE public.role (
    id integer NOT NULL,
    title text NOT NULL,
    description text,
    path public.ltree NOT NULL
);
CREATE SEQUENCE public.role_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE public.role_id_seq OWNED BY public.role.id;
CREATE TABLE public.smart_plug (
    id integer NOT NULL,
    name text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    lab_station_id integer NOT NULL,
    deleted_at timestamp with time zone,
    chip_id text NOT NULL,
    model text NOT NULL
);
COMMENT ON TABLE public.smart_plug IS 'A smart plug is a device used to turn lab equipments into IoT-enabled devices. It receives commands and generates metrics via MQTT.';
CREATE SEQUENCE public.smart_plug_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE public.smart_plug_id_seq OWNED BY public.smart_plug.id;
CREATE VIEW public.smart_plug_status AS
 SELECT s.chip_id,
        CASE
            WHEN ((data.power = (0)::numeric) AND (data."time" >= (now() - '00:01:00'::interval))) THEN 'off'::text
            WHEN ((data.power <> (0)::numeric) AND (data."time" >= (now() - '00:01:00'::interval))) THEN 'on'::text
            ELSE 'unreachable'::text
        END AS status,
    data."time" AS last_message_timestamp
   FROM (public.smart_plug s
     LEFT JOIN LATERAL ( SELECT m."time",
            m.power,
            m.smart_plug_chip_id
           FROM public.smart_plug_metrics m
          WHERE (s.chip_id = m.smart_plug_chip_id)
          ORDER BY m."time" DESC
         LIMIT 1) data ON (true))
  ORDER BY s.chip_id, data."time" DESC;
CREATE TABLE public.smart_plug_tag (
    id integer NOT NULL,
    smart_plug_id integer,
    path public.ltree NOT NULL
);
CREATE SEQUENCE public.smart_plug_tag_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE public.smart_plug_tag_id_seq OWNED BY public.smart_plug_tag.id;
CREATE TABLE public.student_group (
    id integer NOT NULL,
    lab_id integer NOT NULL,
    broker_login text NOT NULL,
    display_name text,
    comment text
);
CREATE SEQUENCE public.student_group_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE public.student_group_id_seq OWNED BY public.student_group.id;
CREATE TABLE public.student_group_metrics (
    "time" timestamp with time zone NOT NULL,
    topic text NOT NULL,
    content text NOT NULL,
    broker_login text NOT NULL
);
CREATE SEQUENCE public.workbench_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE public.workbench_id_seq OWNED BY public.lab_station.id;
ALTER TABLE ONLY public.command ALTER COLUMN id SET DEFAULT nextval('public.command_id_seq'::regclass);
ALTER TABLE ONLY public.command_selector ALTER COLUMN id SET DEFAULT nextval('public.command_selector_id_seq'::regclass);
ALTER TABLE ONLY public.lab ALTER COLUMN id SET DEFAULT nextval('public.laboratory_id_seq'::regclass);
ALTER TABLE ONLY public.lab_station ALTER COLUMN id SET DEFAULT nextval('public.workbench_id_seq'::regclass);
ALTER TABLE ONLY public.lab_user_role ALTER COLUMN id SET DEFAULT nextval('public.lab_user_role_id_seq'::regclass);
ALTER TABLE ONLY public.role ALTER COLUMN id SET DEFAULT nextval('public.role_id_seq'::regclass);
ALTER TABLE ONLY public.smart_plug ALTER COLUMN id SET DEFAULT nextval('public.smart_plug_id_seq'::regclass);
ALTER TABLE ONLY public.smart_plug_tag ALTER COLUMN id SET DEFAULT nextval('public.smart_plug_tag_id_seq'::regclass);
ALTER TABLE ONLY public.student_group ALTER COLUMN id SET DEFAULT nextval('public.student_group_id_seq'::regclass);
ALTER TABLE ONLY public.student_group
    ADD CONSTRAINT broker_accounts_display_name_key UNIQUE (broker_login);
ALTER TABLE ONLY public.command
    ADD CONSTRAINT command_lab_id_name_key UNIQUE (lab_id, name);
ALTER TABLE ONLY public.command
    ADD CONSTRAINT command_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.command_selector
    ADD CONSTRAINT command_selector_command_id_target_key UNIQUE (command_id, selector);
ALTER TABLE ONLY public.command_selector
    ADD CONSTRAINT command_selector_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.command_type
    ADD CONSTRAINT command_type_pkey PRIMARY KEY (type);
ALTER TABLE ONLY public.command_type
    ADD CONSTRAINT command_type_type_key UNIQUE (type);
ALTER TABLE ONLY public.lab_user_role
    ADD CONSTRAINT lab_user_role_lab_id_user_id_key UNIQUE (lab_id, user_id);
ALTER TABLE ONLY public.lab_user_role
    ADD CONSTRAINT lab_user_role_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public."user"
    ADD CONSTRAINT lab_users_email_key UNIQUE (email);
ALTER TABLE ONLY public."user"
    ADD CONSTRAINT lab_users_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.lab
    ADD CONSTRAINT laboratory_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.role
    ADD CONSTRAINT role_path_key UNIQUE (path);
ALTER TABLE ONLY public.role
    ADD CONSTRAINT role_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.smart_plug
    ADD CONSTRAINT smart_plug_chip_id_key UNIQUE (chip_id);
ALTER TABLE ONLY public.smart_plug
    ADD CONSTRAINT smart_plug_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.smart_plug_tag
    ADD CONSTRAINT smart_plug_tag_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.smart_plug_tag
    ADD CONSTRAINT smart_plug_tag_smart_plug_id_path_key UNIQUE (smart_plug_id, path);
ALTER TABLE ONLY public.student_group
    ADD CONSTRAINT student_group_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.lab_station
    ADD CONSTRAINT workbench_pkey PRIMARY KEY (id);
CREATE INDEX role_index ON public.role USING gist (path);
CREATE INDEX smart_plug_metrics_time_idx ON public.smart_plug_metrics USING btree ("time" DESC);
CREATE INDEX smart_plug_tag_index ON public.smart_plug_tag USING gist (path);
CREATE INDEX student_group_metrics_time_idx ON public.student_group_metrics USING btree ("time" DESC);
CREATE TRIGGER set_public_command_updated_at BEFORE UPDATE ON public.command FOR EACH ROW EXECUTE FUNCTION public.set_current_timestamp_updated_at();
COMMENT ON TRIGGER set_public_command_updated_at ON public.command IS 'trigger to set value of column "updated_at" to current timestamp on row update';
CREATE TRIGGER set_public_laboratory_updated_at BEFORE UPDATE ON public.lab FOR EACH ROW EXECUTE FUNCTION public.set_current_timestamp_updated_at();
COMMENT ON TRIGGER set_public_laboratory_updated_at ON public.lab IS 'trigger to set value of column "updated_at" to current timestamp on row update';
CREATE TRIGGER set_public_smart_plug_updated_at BEFORE UPDATE ON public.smart_plug FOR EACH ROW EXECUTE FUNCTION public.set_current_timestamp_updated_at();
COMMENT ON TRIGGER set_public_smart_plug_updated_at ON public.smart_plug IS 'trigger to set value of column "updated_at" to current timestamp on row update';
CREATE TRIGGER set_public_student_group_updated_at BEFORE UPDATE ON public.student_group FOR EACH ROW EXECUTE FUNCTION public.set_current_timestamp_updated_at();
COMMENT ON TRIGGER set_public_student_group_updated_at ON public.student_group IS 'trigger to set value of column "updated_at" to current timestamp on row update';
CREATE TRIGGER set_public_workbench_updated_at BEFORE UPDATE ON public.lab_station FOR EACH ROW EXECUTE FUNCTION public.set_current_timestamp_updated_at();
COMMENT ON TRIGGER set_public_workbench_updated_at ON public.lab_station IS 'trigger to set value of column "updated_at" to current timestamp on row update';
CREATE TRIGGER ts_insert_blocker BEFORE INSERT ON public.smart_plug_metrics FOR EACH ROW EXECUTE FUNCTION _timescaledb_internal.insert_blocker();
CREATE TRIGGER ts_insert_blocker BEFORE INSERT ON public.student_group_metrics FOR EACH ROW EXECUTE FUNCTION _timescaledb_internal.insert_blocker();
ALTER TABLE ONLY public.command
    ADD CONSTRAINT command_lab_id_fkey FOREIGN KEY (lab_id) REFERENCES public.lab(id) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE ONLY public.command_selector
    ADD CONSTRAINT command_selector_command_id_fkey FOREIGN KEY (command_id) REFERENCES public.command(id) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE ONLY public.command
    ADD CONSTRAINT command_type_fkey FOREIGN KEY (type) REFERENCES public.command_type(type) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE ONLY public.lab_station
    ADD CONSTRAINT lab_station_lab_id_fkey FOREIGN KEY (lab_id) REFERENCES public.lab(id) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE ONLY public.lab_user_role
    ADD CONSTRAINT lab_user_role_lab_id_fkey FOREIGN KEY (lab_id) REFERENCES public.lab(id) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE ONLY public.lab_user_role
    ADD CONSTRAINT lab_user_role_role_id_fkey FOREIGN KEY (role_id) REFERENCES public.role(id) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE ONLY public.lab_user_role
    ADD CONSTRAINT lab_user_role_user_id_fkey FOREIGN KEY (user_id) REFERENCES public."user"(id) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE ONLY public.smart_plug
    ADD CONSTRAINT smart_plug_lab_station_id_fkey FOREIGN KEY (lab_station_id) REFERENCES public.lab_station(id) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE ONLY public.smart_plug_metrics
    ADD CONSTRAINT smart_plug_metrics_smart_plug_chip_id_fkey FOREIGN KEY (smart_plug_chip_id) REFERENCES public.smart_plug(chip_id) ON UPDATE CASCADE;
ALTER TABLE ONLY public.smart_plug_tag
    ADD CONSTRAINT smart_plug_tag_smart_plug_id_fkey FOREIGN KEY (smart_plug_id) REFERENCES public.smart_plug(id) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE ONLY public.student_group
    ADD CONSTRAINT student_group_lab_id_fkey FOREIGN KEY (lab_id) REFERENCES public.lab(id) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE ONLY public.student_group_metrics
    ADD CONSTRAINT student_group_metrics_broker_login_fkey FOREIGN KEY (broker_login) REFERENCES public.student_group(broker_login) ON UPDATE CASCADE;
